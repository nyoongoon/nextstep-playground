## [NEXTSTEP 플레이그라운드의 미션 진행 과정](https://github.com/next-step/nextstep-docs/blob/master/playground/README.md)

---
## 학습 효과를 높이기 위해 추천하는 미션 진행 방법

---
1. 피드백 강의 전까지 미션 진행 
> 피드백 강의 전까지 혼자 힘으로 미션 진행. 미션을 진행하면서 하나의 작업이 끝날 때 마다 add, commit
> 예를 들어 다음 숫자 야구 게임의 경우 0, 1, 2단계까지 구현을 완료한 후 push

![mission baseball](https://raw.githubusercontent.com/next-step/nextstep-docs/master/playground/images/mission_baseball.png)

---
2. 피드백 앞 단계까지 미션 구현을 완료한 후 피드백 강의를 학습한다.

---
3. Git 브랜치를 master 또는 main으로 변경한 후 피드백을 반영하기 위한 새로운 브랜치를 생성한 후 처음부터 다시 미션 구현을 도전한다.

```
git branch -a // 모든 로컬 브랜치 확인
git checkout master // 기본 브랜치가 master인 경우
git checkout main // 기본 브랜치가 main인 경우

git checkout -b 브랜치이름
ex) git checkout -b apply-feedback
```


# 숫자야구게임 피드백
## 테스트 주도 개발로 구현하기
- 메소드 분리, 클래스 설계에 대한 학습
- 단위테스트와는 다른점은 -> TDD에는 리팩토링이라는 사이클이 항상 포함되어 있음! 
- TDD란 프로그래밍 의사결정과 피드백 사이의 간극을 의식하고 이를 제어하는 기술
- TDD의 아이러니 중 하나는 테스트 기술이 아니라는점. TDD는 분석기술이며 설계기술이기도 하다.
## TDD하는 이유
- 디버깅 시간 줄여줌
- 동작하는 문서 역할을 함
- 변화에 대한 두려움 줄여줌.
## 사이클
- Test fails : 실패하는 테스트를 구현한다.
- Test Passes : 테스트가 성공하도록 코드를 구현한다
- Refactor : 프로덕션 코드와 테스트코드를 리팩토링한다 
## TDD 원칙
- 원칙 1 : 실패하는 단위 테스트를 작성할 때까지 프로덕션 코드를 작성하지 않는다
- 원칙 2 : 컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위 테스트를 작성한다
- 원칙 3 : 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다. 
## 단위테스트, TDD를 시작할 때의 감정 상태
- 어디서, 어떻게 시작해야할지 모르겠다. 막막함. 
## 도메인 지식, 객체 설계 경험이 있는 경우
- 요구사항 분석을 통해 대략적인 설계 -> 객체 추출
- UI, DB 등과 의존관계를 가지지 않는 핵심 도메인 영역을 집중 설계 
### 1차적으로 도메인 로직을 테스트하는 것에 집중
![](/img/img.png)
- -> 뷰와 컨트롤러를 배제하고, 도메인영역(서비스)을 설계한 후, 이 부분에 대한 단위테스트를 진행 (우선적으로)
- 대략적인 도메인 설계 
![](/img/img_1.png)
- -> 랜덤값 생성은 테스트하기 힘든 영역이므로 분리하는것이 필요
- -> 테스트 용이한 영역과 테스트 힘든 영역을 분리하는것이 중요 역량 
## 객체 설계 경험이 없는 경우
### 1. 구현할 기능 목록 작성하기
- 구현할 기능 목록을 작성한 후에 TDD로 도전
- 기능 목록을 작성하는 것도 역량이 필요한 것 아닌가?
- 역량도 중요하지만 연습이 필요하다.. 
### 2. 그래도 막막하다면
- 단위 테스트도 없고, TDD도 아니고, 객체 설계도 하지 않고, 기능 목록을 분리하지도 않고 지금까지 익숙한 방식으로 일단 구현
- 구현하려는 프로그래밍의 도메인 지식을 쌓는다. -> 도메인 지식이 쌓이면 TodoList(기능목록)작성하는 것이 수월해짐
- 구현한 모든 코드를 버린다. 
- 구현할 기능 목록 작성 또는 간단한 도메인 설계
- 기능 목록 중 가장 만만한 녀석부터 TDD 구현 시작
- 복잡도가 높아져 리팩토링하기 힘든 상태가 되면 버린다
- 다시 도전
- **-> 아무것도 없는 상태에서 새롭게 구현하는 것보다 레거시 코드가 있는 상태에 리팩토링하는 것이 몇 배 더 어렵다.**